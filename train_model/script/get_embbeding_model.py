from typing import Union
from pathlib import Path
from script.dataset import Dataset
from script.get_embbeding_algorithm import get_embbeding_algorithm
import torch
import torch.nn as nn
import torch.optim as optim
from script.get_node_feature import get_record_feature


def get_embbeding_model(
        conv_count: int,
        conv_algorithm: str,
        input_dimension: int,
        model_path: Union[str, Path],
        dataset: Dataset
):
    model = get_embbeding_algorithm(
        input_dimension, conv_count, conv_algorithm)
    model_path = Path(f'{model_path}/{conv_algorithm}{conv_count}.pth')
    train_graph, _, _, _ = dataset.get_shuffle()
    if not model_path.exists():
        print("startTrainning")
        optimizer = optim.Adam(model.parameters(), lr=0.01)
        criterion = nn.MSELoss()

        for _ in range(1):
            for record in train_graph:
                features = get_record_feature(record)
                print(features)
                h = model(record, features)
                loss = criterion(h, features)

                optimizer.zero_grad()
                loss.backward()
                optimizer.step()
        torch.save(model.state_dict(), model_path)
    model.load_state_dict(torch.load(f'{model_path}'))
    return model
