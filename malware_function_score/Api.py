
import os
import joblib as J
import multiprocessing
from networkx import MultiDiGraph
from androguard.misc import AnalyzeAPK
from androguard.core.analysis.analysis import MethodAnalysis
from typing import List, NewType

class Api:
    @staticmethod
    def get_parameters(node: MethodAnalysis):
        description = str(node.get_descriptor()).split(')')[0][1:] + " "
        if not description:
            return ''
        enum_dict = {
            "B ": "byte ",
            "I ": "int ",
            "J ": "long ",
            "D ": "double ",
            "Z ": "boolean ",
            "F ": "float ",
            "C": "char",
            "S": "short"
        }
        parameters = ''
        for k,v in enum_dict.items():
            description = description.replace(k,v)
        
        description = [s for s in description.replace(";", " ").split(" ") if s]
        for parameter in description:
            array_count = parameter.count('[')
            parameter = parameter[array_count:]
            if parameter[0] == 'L':
                parameter = parameter[1:]
            for _ in range(array_count):
                parameter += "[]"
            parameters += f",{parameter}"
        return parameters[1:].replace("/",".")


    def __init__(self, node: MethodAnalysis = None, node_str: str = None):
        self.in_benigh = 0
        self.in_malware = 0
        if node is not None:
            self.node = node
            self.class_name = str(node.class_name)[1:-1].replace("/n","").replace("/",".")
            self.method = node.method.name
            self.parameters = Api.get_parameters(node)
        
        if node_str is not None:
            line = [x.strip()[1:-1] for x in node_str.split(" ")]
            self.node = None
            self.class_name = line[0]
            self.method = line[1]
            self.parameters = line[2]

    def __eq__(self, other: object) -> bool:
        return (self.class_name == other.class_name and
                    self.method == other.method and 
                    self.parameters == other.parameters)
        if self.node is not None and other.node is not None:
            print('test')
            return str(self.node) == str(other.node)
        else:
            return (self.class_name == other.class_name and
                    self.method == other.method and 
                    self.parameters == other.parameters)
        
    def __hash__(self) -> int:
        return hash((self.class_name, self.method, self.parameters))
    
    def __str__(self) -> str:
        return ("\n========================================\n"
            # f"Node: {self.node}\n"
            f"Class name: {self.class_name}\n"
            f"Method: {self.method}\n"
            f"Parameters: {self.parameters}\n"
            f"In Benigh: {self.in_benigh}\n"
            f"In Malware: {self.in_malware}\n"
            "========================================\n")
    
    @staticmethod
    def get_api_from_txt(paths: List[str]):
        api_list = []
        for path in paths:
            try:
                with open(path, 'r') as file:
                    for line in file.readlines():
                        api_list.append(Api(node_str=line))
            except FileNotFoundError:
                pass
        return api_list

    
    @staticmethod
    def get_api_from_apk(paths: List[str], isBenign = False):
        test = []
        api_list = set()
        count,sum = 0, len(paths)
        def get_api_from_single_apk(path):
            nonlocal count
            nonlocal sum
            nonlocal api_list
            count += 1
            print(f'{count}/{sum}')
            _, _, dx = AnalyzeAPK(path)
            cg = dx.get_call_graph()
            for node in cg.nodes:
                api = Api(node=node)
                if api not in api_list:
                    api_list.add(api)
                existing_api = next(x for x in api_list if x == api)
                if "benigh" in path.split('/')[-1].lower():
                    existing_api.in_benigh += 1
                else:
                    existing_api.in_malware += 1
        try:
            # J.Parallel(n_jobs=4)(J.delayed(get_api_from_single_apk)(path) for path in paths[:2]) 
            for path in paths[:10]:
                get_api_from_single_apk(path)  
        except:
            print(paths)
            pass
        print(api_list)
        return api_list
        

ApiType = NewType('ApiType',Api)

# for i in Api.get_api_from_txt(['process_dataset/sensitive_apis/pscoutApi.txt'])[:10]:
#     print(i)
# 
_, _, dx = AnalyzeAPK('dataset/train/Adware0077.apk')
cg = dx.get_call_graph()

node = enumerate(cg.nodes)
# for i,v in node:
#     print(i, Api(node=v))
test_dir = [f'dataset/test/{name}' for name in os.listdir('dataset/test')]

tmp = list(Api.get_api_from_apk(test_dir))
with open("malware_function_score/prototype_score.api", 'a')  as file:
    for line in tmp:
        file.write(f'|{line.class_name}| |{line.method}| |{line.parameters}| |{line.in_benigh}| |{line.in_malware}| \n')
