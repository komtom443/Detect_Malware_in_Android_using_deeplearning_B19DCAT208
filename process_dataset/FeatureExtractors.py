import os
import torch
import networkx as nx

from pathlib import Path
from pygtrie import StringTrie
from networkx import MultiDiGraph
from typing import Dict, List, Optional
from androguard.core.analysis.analysis import MethodAnalysis

ATTRIBUTES = ['external', 'entrypoint', 'native',
              'public', 'static', 'codesize', 'api', 'user', 'center', 'degree', 'permissions']
package_directory = os.path.dirname(os.path.abspath(__file__))


def memoize(function):
    memo = {}

    def wrapper(*args):
        if args in memo:
            return memo[args]
        else:
            rv = function(*args)
            memo[args] = rv
            return rv

    return wrapper


class FeatureExtractors:
    NUM_PERMISSION_GROUPS = 59
    NUM_API_PACKAGES = 226
    NUM_OPCODE_MAPPINGS = 21

    @staticmethod
    def _get_opcode_mapping() -> Dict[str, int]:
        mapping = {x: i for i, x in enumerate(['nop', 'mov', 'return',
                                               'const', 'monitor', 'check-cast', 'instanceof', 'new',
                                               'fill', 'throw', 'goto/switch', 'cmp', 'if', 'unused',
                                               'arrayop', 'instanceop', 'staticop', 'invoke',
                                               'unaryop', 'binop', 'inline'])}
        mapping['invalid'] = -1
        return mapping

    @staticmethod
    @memoize
    def _get_instruction_type(op_value: int) -> str:
        if 0x00 == op_value:
            return 'nop'
        elif 0x01 <= op_value <= 0x0D:
            return 'mov'
        elif 0x0E <= op_value <= 0x11:
            return 'return'
        elif 0x12 <= op_value <= 0x1C:
            return 'const'
        elif 0x1D <= op_value <= 0x1E:
            return 'monitor'
        elif 0x1F == op_value:
            return 'check-cast'
        elif 0x20 == op_value:
            return 'instanceof'
        elif 0x22 <= op_value <= 0x23:
            return 'new'
        elif 0x24 <= op_value <= 0x26:
            return 'fill'
        elif 0x27 == op_value:
            return 'throw'
        elif 0x28 <= op_value <= 0x2C:
            return 'goto/switch'
        elif 0x2D <= op_value <= 0x31:
            return 'cmp'
        elif 0x32 <= op_value <= 0x3D:
            return 'if'
        elif (0x3E <= op_value <= 0x43) or (op_value == 0x73) or (0x79 <= op_value <= 0x7A) or (
                0xE3 <= op_value <= 0xED):
            return 'unused'
        elif (0x44 <= op_value <= 0x51) or (op_value == 0x21):
            return 'arrayop'
        elif (0x52 <= op_value <= 0x5F) or (0xF2 <= op_value <= 0xF7):
            return 'instanceop'
        elif 0x60 <= op_value <= 0x6D:
            return 'staticop'
        elif (0x6E <= op_value <= 0x72) or (0x74 <= op_value <= 0x78) or (0xF0 == op_value) or (
                0xF8 <= op_value <= 0xFB):
            return 'invoke'
        elif 0x7B <= op_value <= 0x8F:
            return 'unaryop'
        elif 0x90 <= op_value <= 0xE2:
            return 'binop'
        elif 0xEE == op_value:
            return 'inline'
        else:
            return 'invalid'

    @staticmethod
    def _mapping_to_bitstring(mapping: List[int], max_len) -> torch.Tensor:
        size = torch.Size([1, max_len])
        if len(mapping) > 0:
            indices = torch.LongTensor([[0, x] for x in mapping]).t()
            values = torch.LongTensor([1] * len(mapping))
            tensor = torch.sparse.LongTensor(indices, values, size)
        else:
            tensor = torch.sparse.LongTensor(size)
        return tensor.to_dense().squeeze()

    @staticmethod
    def _get_api_trie() -> StringTrie:
        apis = open("process_dataset/metadata/api.list").readlines()
        api_list = {x.strip(): i for i, x in enumerate(apis)}
        api_trie = StringTrie(separator='.')
        for k, v in api_list.items():
            api_trie[k] = v
        return api_trie

    @staticmethod
    @memoize
    def get_api_features(api: MethodAnalysis) -> Optional[torch.Tensor]:
        if not api.is_external():
            return None
        api_trie = FeatureExtractors._get_api_trie()
        name = str(api.class_name)[1:-1].replace('/', '.')
        _, index = api_trie.longest_prefix(name)
        if index is None:
            indices = []
        else:
            indices = [index]
        feature_vector = FeatureExtractors._mapping_to_bitstring(
            indices, FeatureExtractors.NUM_API_PACKAGES)
        return feature_vector

    @staticmethod
    @memoize
    def get_user_features(user: MethodAnalysis) -> Optional[torch.Tensor]:
        if user.is_external():
            return None
        opcode_mapping = FeatureExtractors._get_opcode_mapping()
        opcode_groups = set()
        for instr in user.get_method().get_instructions():
            instruction_type = FeatureExtractors._get_instruction_type(
                instr.get_op_value())
            instruction_id = opcode_mapping[instruction_type]
            if instruction_id >= 0:
                opcode_groups.add(instruction_id)
        feature_vector = FeatureExtractors._mapping_to_bitstring(
            list(opcode_groups), len(opcode_mapping) - 1)
        return torch.LongTensor(feature_vector)

    @staticmethod
    # @memoize
    def get_permission_features(node: MethodAnalysis, permission_mapping: Dict[MethodAnalysis, List[str]]) -> Optional[torch.Tensor]:
        res = torch.zeros(FeatureExtractors.NUM_PERMISSION_GROUPS)
        permissions = open(
            "process_dataset/metadata/permission.list").readlines()
        permission_list = {x.strip(): i for i, x in enumerate(permissions)}
        if node in permission_mapping:
            for permission in permission_mapping[node]:
                try:
                    res[permission_list[permission.split('.')[-1]]] = 1
                except:
                    res
        return res
